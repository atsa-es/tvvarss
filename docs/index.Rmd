---
title: "TVVARSS simulation and fitting"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
    toc_depth: 3
    fig_caption: yes
---

***

This is version `r paste0('0.',format(Sys.time(), '%y.%m.%d'))`.

***

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background

Fill in some background info.

# Requirements

All analyses require the [R software](https://cran.r-project.org/) (v3.3) for data simulation, processing, and summarizing model results, and the [Stan software](http://mc-stan.org/) for Hamiltonian Monte Carlo (HMC) simulation. Please note that some of the R code below may not work with older versions of JAGS due to some changes in the ways that arrays are handled.

We also need a few packages that are not included with the base installation of R, so we begin by installing them (if necessary) and then loading them.

```{r load_pkgs, message=FALSE, warning=FALSE}
if(!require("tvvarss")) {
  if(!require("devtools")) {
    install.packages("devtools")
    library("devtools")
  }
  devtools::install_github("eric-ward/tvvarss")
  library("tvvarss")
}
```

# Step 1: Simulate data

We use the function `simTVVAR` from the `tvvarss` package to simulate the process component of a TVVARSS model (_i.e._, it does not add observation error). To do so, we must express the food web topology via the matrix $\mathbf{B}_t$. Specifically, interactions are expressed as the effect of column on row; the diagonals indicate the strength of density-dependence. All elements of the matrix corresponding to no interaction are set to 0.

`tvvarss` is designed to work with symbolic representations within $\mathbf{B}_t$, based on the following codes:

* `"dd"`: density-dependence (this is implied in TVVARSS models)
* `"td"`: top-down
* `"bu"`: bottom-up
* `"cf"`: competitive/facilitative

We show four different examples of simulated food web topologies. 

## Ex 1: Linear food chain

Here there are 4 tropic levels stacked in a linear food chain from primary producers `PP` at the bottom to tertiay consumers `TC` at the top.

```{r ex_1_graphic}
lvls <- c("TC","SC","PC","PP")
cat(paste0(paste0(lvls[1:3],"\n|\n",collapse = ""),lvls[4]))
```

Here is the topology in a matrix form that `tvvarss` will understand.

```{r ex_1_B0}
nn <- length(lvls)
## initial conditions for B_t
B0_lfc <- matrix(list(0),nn,nn)
dimnames(B0_lfc) <- list(lvls,lvls)
## diagonal elements = density-dependence
diag(B0_lfc) <- rep("dd",4)
for(i in 1:(nn-1)) {
  B0_lfc[i,i+1] <- "bu"
  B0_lfc[i+1,i] <- "td"
}
## inspect B0
B0_lfc
```

We can now simulate a TVVAR process based on this expression of the food web topology. In addition to the matrix specifying the topology, the simulator needs to know the length of time series and some information about the variances of the process errors for $\mathbf{B}_t$ and the states $\mathbf{x}_t$.

Here is a 30-unit long TVVAR model.

```{r ex_1_sim}
TT <- 35
## simulate
set.seed(666)
lfc <- simTVVAR(B0 = B0_lfc, TT = TT,
                var_QX = seq(4)/40, cov_QX = 0,
                var_QB = 0.05, cov_QB = 0)
```

And we can plot the states over time.

```{r ex_1_plot_state, fig.height=3, fig.width=7}
par(mai=c(0.9,0.9,0,0), omi=c(0.1,0.1,0.1,1.5))
clr <- c("purple","darkred","blue","darkgreen")
matplot(t(lfc$states), type="l", lty="solid", lwd=2, xpd=NA,
        col=clr)
legend("right", legend=lvls, lty="solid", lwd=2,
       col=clr, inset=-0.2, xpd=NA)
```

Let's simulate many TVVAR models of this form and inspect them.

```{r ex_1_lots, fig.height=3, fig.width=7}
ee <- 10
ex1 <- vector("list",ee)
clr <- c("purple","darkred","blue","darkgreen")
for(i in 1:ee) {
  ex1[[i]] <- simTVVAR(B0 = B0_lfc, TT = TT,
                       var_QX = seq(4)/40, cov_QX = 0,
                       var_QB = 0.05, cov_QB = 0)
  par(mai=c(0.6,0.9,0.3,0), omi=c(0.1,0.1,0.1,1.5))
  matplot(t(ex1[[i]]$states), type="l", lty="solid", lwd=2, xpd=NA,
          col=clr, main=paste0("Sim ",i), ylab="Log density")
  legend("right", legend=lvls, lty="solid", lwd=2,
         col=clr, inset=-0.2, xpd=NA)
}
```

OK, clearly some of them exhibit unrealistic, explosive population dynamics. Let's develop a screening process to toss those out.

```{r ex_1_screening, fig.height=3, fig.width=7}
clr <- c("purple","darkred","blue","darkgreen")
## number of simulations
ee <- 10
## min log-density threshold
dens_min <- -6
## max log-density threshold
dens_max <- 10
ex1 <- vector("list",ee)
for(i in 1:ee) {
  tmp <- list(states=2*rep(dens_max,2))
  while(max(tmp$states) > dens_max | min(tmp$states) < dens_min) {
    tmp <- simTVVAR(B0 = B0_lfc, TT = TT,
                    var_QX = seq(4)/40, cov_QX = 0,
                    var_QB = 0.05, cov_QB = 0)
  }
  ex1[[i]] <- tmp
  par(mai=c(0.6,0.9,0.3,0), omi=c(0.1,0.1,0.1,1.5))
  matplot(t(ex1[[i]]$states), type="l", lty="solid", lwd=2, xpd=NA,
          col=clr, main=paste0("Simulation ",i), ylab="Log density")
  legend("right", legend=lvls, lty="solid", lwd=2,
         col=clr, inset=-0.2, xpd=NA, cex=0.9)
}
```


