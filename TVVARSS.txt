

model {

  #--------
	# PRIORS
	#--------
  # BB is interaction matrix
  # precision matrix
  BB_tau ~ dwish(BB_prior, M2); 
  BB_tau_off ~ dgamma(0.001,0.001);
  BB_tau_diag ~ dgamma(0.001,0.001);    

  # initial X0, or state of nature, varies by state, but shared prior
  X0.tau ~ dwish(Bprior[1:m,1:m], m); # prior precision matrix
  X.1[1:m,1] ~ dmnorm(Bz[1:m],X0.tau); # state 1
  X.2[1:m,1] ~ dmnorm(Bz[1:m],X0.tau); # state 2
  X.3[1:m,1] ~ dmnorm(Bz[1:m],X0.tau); # state 3
  X.4[1:m,1] ~ dmnorm(Bz[1:m],X0.tau); # state 4
				
  # process variance is independent/unequal by region
  # and independent/unequal across spp
  for(i in 1:m) {
    for(j in 1:3) {
      tauQ[i,j] ~ dgamma(0.01,0.01);
    }		
  }

  B1.offDiagTau ~ dgamma(0.001,0.001);
  B1.diagTau ~ dgamma(0.001,0.001);    

  # Priors for coefficients  
  for(i in 1:m) {
    CC[i,1] ~ dnorm(0,1); # effect of enso, varies by spp
    DD[i,1] ~ dnorm(0,1); # effect of otters, varies by spp
  }
  for(i in 1:13) {
    EE[i,1] <- 0; # effect of urchin harvest on non-urchin
  }
  EE[14,1] ~ dnorm(0,1); # effect of urchin harvest on urchins

  for(time in 2:n) {
    for(cols in 1:m) {
      # go from vec space -> matrix, but i think it's only way in jags
      Bmat.1[1:m,cols,time] <- B1.1[Bindices[1,cols]:Bindices[m,cols],time-1];    	   
    }
    	
    # calculate predicted state vector for states 1-4
    predX.1[1:m,time] <- Bmat.1[1:m,1:m,time-1] %*% (X.1[1:m,time-1]) + 
                         CC[1:m,1] * enso.wns[time-1,] +
                         DD[1:m,1] * otters.w[time-1,] +
                         EE[1:m,1] * harvest.wns[time-1,];#site 2/3

    predX.2[1:m,time] <- Bmat.1[1:m,1:m,time-1] %*% (X.2[1:m,time-1]) +
                         CC[1:m,1] * enso.wns[time-1,] +
                         DD[1:m,1] * otters.n[time-1,] +
                         EE[1:m,1] * harvest.wns[time-1,];#site 1
    	
    predX.3[1:m,time] <- Bmat.1[1:m,1:m,time-1] %*% (X.3[1:m,time-1]) +
                         CC[1:m,1] * enso.wns[time-1,] +
                         DD[1:m,1] * otters.s[time-1,] +
                         EE[1:m,1] * harvest.wns[time-1,];#site 4/5

    predX.4[1:m,time] <- Bmat.1[1:m,1:m,time-1] %*% (X.4[1:m,time-1]) +
                         CC[1:m,1] * enso.wns[time-1,] +
                         DD[1:m,1] * otters.s[time-1,] +
                         EE[1:m,1] * harvest.wns[time-1,];#site 6

    # include process variation - normally distributed errors
    # independent across spp and site
    for(spp in 1:m) {
      X.1[spp,time] ~ dnorm(predX.1[spp,time], tauQ[spp,1]);
      X.2[spp,time] ~ dnorm(predX.2[spp,time], tauQ[spp,2]);
      X.3[spp,time] ~ dnorm(predX.3[spp,time], tauQ[spp,3]);
      X.4[spp,time] ~ dnorm(predX.4[spp,time], tauQ[spp,3]);		    		
    }

  # update B0 and B1
    for(i in 1:(m*m-m)) {
      # off diagonal elements of B1 -- interactions
      B1.1[Boffdiag[i],time] ~ dnorm(B1.1[Boffdiag[i],time-1], B1.offDiagTau);	    		    	
    }
    for(i in 1:m) {
      # Diagonal elements of B1 -- density dep
      B1.1[Bdiag[i],time] ~ dnorm(B1.1[Bdiag[i],time-1], B1.diagTau);	    		    	
    }
  } # end time loop

  # observation / data model, assume R = diag and equal
  for(i in 1:m) {
    tauR[i] ~ dgamma(0.001,0.001);
  }	

  for(time in 1:n) {
    for(spp in 1:m) {
      Y2[spp,time] ~ dnorm(X.1[spp,time],tauR[spp]);
      Y3[spp,time] ~ dnorm(X.1[spp,time],tauR[spp]);
      Y1[spp,time] ~ dnorm(X.2[spp,time],tauR[spp]);
      Y4[spp,time] ~ dnorm(X.3[spp,time],tauR[spp]);
      Y5[spp,time] ~ dnorm(X.3[spp,time],tauR[spp]);
      Y6[spp,time] ~ dnorm(X.4[spp,time],tauR[spp]);																		
    }
  }
	
} # end JAGS model description

