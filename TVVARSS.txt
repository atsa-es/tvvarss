

model {

  #--------
  # PRIORS
  #--------
  # BB is interaction matrix
  # precision matrix
  BB_tau ~ dwish(BB_prior, M2); 
  BB_tau_off ~ dgamma(0.001,0.001);
  BB_tau_diag ~ dgamma(0.001,0.001);    

  # initial X0, or state of nature, varies by state, but shared prior
  X0_tau ~ dwish(BB_prior[1:MM,1:MM], MM); # prior precision matrix
      	
  # process variance is independent/unequal by region
  # and independent/unequal across spp
  for(i in 1:MM) {
    for(j in 1:3) {
      QQ_tau[i,j] ~ dgamma(0.01,0.01);
    }		
  }

  # Priors for covariate effects  
  for(i in 1:MM) {
    CC_enso[i,1] ~ dnorm(0,0.001); # effect of enso, varies by spp
    CC_ottr[i,1] ~ dnorm(0,0.001); # effect of otters, varies by spp
  }
  for(i in 1:(MM-1)) {
    CC_harv[i,1] <- 0; # effect of urchin harvest on non-urchin
  }
  CC_harv[MM,1] ~ dnorm(0,0.001); # effect of urchin harvest on urchins

  #------------
  # LIKELIHOOD
  #------------
  # first time step
  BB_vec[1:M2,1] ~ dmnorm(BB_mean,BB_tau);  # interactions at time 1
  # convert BB_vec to a matrix for initial time step  
  for(cols in 1:MM) {
    BB_mat[1:MM,cols,1] <- BB_vec[BB_idx[1,cols]:BB_idx[MM,cols],1];            
  }

  X_1[1:MM,1] ~ dmnorm(BB_mean[1:MM],X0_tau); # state 1
  X_2[1:MM,1] ~ dmnorm(BB_mean[1:MM],X0_tau); # state 2
  X_3[1:MM,1] ~ dmnorm(BB_mean[1:MM],X0_tau); # state 3
  X_4[1:MM,1] ~ dmnorm(BB_mean[1:MM],X0_tau); # state 4
  
  # time steps 2:TT
  for(time in 2:TT) {
    for(cols in 1:MM) {
      # go from vec space -> matrix, but i think it's only way in jags
      BB_mat[1:MM,cols,time] <- BB_vec[BB_idx[1,cols]:BB_idx[MM,cols],time];    	   
    }
    	
    # calculate predicted state vectors
    mu_X_1[1:MM,time] <- BB_mat[1:MM,1:MM,time] %*% (X_1[1:MM,time-1]) + 
                         CC_enso[1:MM,1] * enso[1,time-1] +
                         CC_ottr[1:MM,1] * ottr[2,time-1] +
                         CC_harv[1:MM,1] * harv[1,time-1];

    mu_X_2[1:MM,time] <- BB_mat[1:MM,1:MM,time] %*% (X_2[1:MM,time-1]) +
                         CC_enso[1:MM,1] * enso[1,time-1] +
                         CC_ottr[1:MM,1] * ottr[1,time-1] +
                         CC_harv[1:MM,1] * harv[1,time-1];

    mu_X_3[1:MM,time] <- BB_mat[1:MM,1:MM,time] %*% (X_3[1:MM,time-1]) +
                         CC_enso[1:MM,1] * enso[1,time-1] +
                         CC_ottr[1:MM,1] * ottr[3,time-1] +
                         CC_harv[1:MM,1] * harv[1,time-1];

    mu_X_4[1:MM,time] <- BB_mat[1:MM,1:MM,time] %*% (X_4[1:MM,time-1]) +
                         CC_enso[1:MM,1] * enso[1,time-1] +
                         CC_ottr[1:MM,1] * ottr[3,time-1] +
                         CC_harv[1:MM,1] * harv[1,time-1];

    # include process variation - normally distributed errors
    # independent across spp and site
    for(spp in 1:MM) {
      X_1[spp,time] ~ dnorm(mu_X_1[spp,time], QQ_tau[spp,1]);
      X_2[spp,time] ~ dnorm(mu_X_2[spp,time], QQ_tau[spp,2]);
      X_3[spp,time] ~ dnorm(mu_X_3[spp,time], QQ_tau[spp,3]);
      X_4[spp,time] ~ dnorm(mu_X_4[spp,time], QQ_tau[spp,3]);		    		
    }

    # update BB
    # off-diagonal elements of BB: interactions
    for(i in 1:(M2-MM)) {
      BB_vec[BB_off[i],time] ~ dnorm(BB_vec[BB_off[i],time-1], BB_tau_off);	    		    	
    }
    # diagonal elements of BB: density dependence
    for(i in 1:MM) {
      BB_vec[BB_diag[i],time] ~ dnorm(BB_vec[BB_diag[i],time-1], BB_tau_diag);	    		    	
    }
  } # end time loop

  # observation / data model; assume RR = diagonal and unequal
  for(i in 1:MM) {
    RR_tau[i] ~ dgamma(0.001,0.001);
  }	

  for(time in 1:TT) {
    for(spp in 1:MM) {
      YY_1[spp,time] ~ dnorm(X_1[spp,time],RR_tau[spp]);
      YY_2[spp,time] ~ dnorm(X_2[spp,time],RR_tau[spp]);
      YY_3[spp,time] ~ dnorm(X_2[spp,time],RR_tau[spp]);
      YY_4[spp,time] ~ dnorm(X_3[spp,time],RR_tau[spp]);
      YY_5[spp,time] ~ dnorm(X_3[spp,time],RR_tau[spp]);
      YY_6[spp,time] ~ dnorm(X_4[spp,time],RR_tau[spp]);																		
    }
  }
	
} # end JAGS model description

